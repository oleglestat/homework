// console.log('start');
//
// const promise1 = new Promise((resolve, reject) => {
// 	console.log(1)
// 	resolve(2)
// })
//
// promise1.then(res => {
// 	console.log(res)
// })
//
// console.log('end');

/*
* Результат: start -> 1 -> end -> 2
*
* Виконавець всередині promise1 виконується негайно, навідміну від resolve(2). Виклик resolve(2) починає асинхронну операцію і параметр переданий до then() додається в кінець черги виконання
* */

// Promise.resolve(1)
// 	.then((x) => x + 1)
// 	.then((x) => { throw new Error('My Error') })
// 	.catch(() => 1)
// 	.then((x) => x + 1)
// 	.then((x) => console.log(x))
// 	.catch(console.error)

/*
* Результат: 2
*
* рядок 22 - Ми створили завершений проміс і передали йому число
* рядок 23 - then отримав число 1 збільшив на 1
* рядок 24 - then отримав число 2 і кинув помилку
* рядок 25 - catch обробив помилку (нічого не робив з нею), не отримав параметром нічого і повернув 1
* рядок 26 - then отримав число 1 збільшив на 1
* рядок 27 - then отримав число 2 і вивів його в консоль
* рядок 28 - catch отримав параметром метод console.error для обробки потенційної помилки в попередньому then
* */

const promise = new Promise(res => res(2));
promise.then(v => {
	console.log(v);
	return v * 2;
	})
	.then(v => {
		console.log(v);
		return v * 2;
	})
	.finally(v => {
		console.log(v);
		return v * 2;
	})
	.then(v => {
		console.log(v);
	});

/*
* Результат: 2
*
* рядок 40 - створили проміс з резолвом 2
* рядок 41-44 - отримали резолв проміса 2, виввели в консоль 2, повернули 4
* рядок 45-48 - отримали резолв проміса 4, виввели в консоль 4, повернули 8
* рядок 49-52 - виконали final, final викликаєтся без аргументів тому консоль вивела undefined. return значення ігнорується
* рядок 53-55 - отримали резолв проміса 8, виводиться 8
* */